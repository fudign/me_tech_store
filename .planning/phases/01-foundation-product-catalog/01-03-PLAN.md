---
phase: 01-foundation-product-catalog
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - app/Http/Controllers/Storefront/ProductController.php
  - app/Http/Controllers/Storefront/SearchController.php
  - resources/views/storefront/products/index.blade.php
  - resources/views/storefront/categories/show.blade.php
  - resources/views/components/product-filter.blade.php
  - routes/web.php
autonomous: true

must_haves:
  truths:
    - "Customer can search products by name"
    - "Customer can filter products by price range"
    - "Customer can filter products by specifications (memory, color)"
    - "Search and filter results update product listing"
    - "Filter state persists in URL for sharing"
  artifacts:
    - path: "app/Http/Controllers/Storefront/SearchController.php"
      provides: "Product search functionality"
      exports: ["index"]
    - path: "resources/views/components/product-filter.blade.php"
      provides: "Filter UI component"
      min_lines: 30
  key_links:
    - from: "resources/views/components/product-filter.blade.php"
      to: "app/Http/Controllers/Storefront/ProductController.php"
      via: "Form submission with query parameters"
      pattern: "form.*action.*products"
    - from: "app/Http/Controllers/Storefront/ProductController.php"
      to: "app/Models/Product.php"
      via: "Query builder with where clauses"
      pattern: "where.*price|where.*name"
---

<objective>
Implement product search and filtering to help customers find products quickly.

Purpose: Enable customers to search by keyword and filter by price range and key specifications (memory, color). This addresses requirements CAT-03, CAT-04, CAT-05 from Phase 1.

Output: Working search functionality and filter sidebar allowing customers to narrow down product listings by multiple criteria.
</objective>

<execution_context>
@C:\Users\user\Desktop\mi_tech\.planning\workflows\execute-plan.md
@C:\Users\user\Desktop\mi_tech\.planning\templates\summary.md
</execution_context>

<context>
@C:\Users\user\Desktop\mi_tech\.planning\PROJECT.md
@C:\Users\user\Desktop\mi_tech\.planning\ROADMAP.md
@C:\Users\user\Desktop\mi_tech\.planning\research\PITFALLS.md

# Reference Plan 02 for existing controllers/views
</context>

<tasks>

<task type="auto">
  <name>Implement product search with safe query handling</name>
  <files>
    app/Http/Controllers/Storefront/SearchController.php
    routes/web.php
    resources/views/layouts/app.blade.php
  </files>
  <action>
    1. Create SearchController (app/Http/Controllers/Storefront/SearchController.php):
       ```php
       namespace App\Http\Controllers\Storefront;

       use App\Http\Controllers\Controller;
       use App\Models\Product;
       use Illuminate\Http\Request;

       class SearchController extends Controller
       {
           public function index(Request $request)
           {
               $query = $request->input('q', '');

               // Validate search query length
               $validated = $request->validate([
                   'q' => 'nullable|string|max:200',
               ]);

               $products = Product::where('is_active', true)
                   ->when($query, function ($queryBuilder) use ($query) {
                       // CRITICAL: Use prepared statements, never concatenate (Pitfall #1: SQL Injection)
                       $queryBuilder->where(function ($q) use ($query) {
                           $q->where('name', 'LIKE', '%' . $query . '%')
                             ->orWhere('description', 'LIKE', '%' . $query . '%')
                             ->orWhere('sku', 'LIKE', '%' . $query . '%');
                       });
                   })
                   ->with('categories')
                   ->paginate(20)
                   ->appends(['q' => $query]);

               return view('storefront.products.search', [
                   'products' => $products,
                   'query' => $query,
                   'total' => $products->total(),
               ]);
           }
       }
       ```

       CRITICAL: Using Eloquent where() with LIKE prevents SQL injection (addresses Pitfall #1)
       CRITICAL: Input validation limits query length to prevent abuse
       CRITICAL: appends(['q' => $query]) maintains search term in pagination links

    2. Add search route to routes/web.php:
       ```php
       use App\Http\Controllers\Storefront\SearchController;

       Route::get('/search', [SearchController::class, 'index'])->name('search');
       ```

    3. Add search form to layout header (resources/views/layouts/app.blade.php):
       ```blade
       <header class="bg-white shadow">
           <div class="container mx-auto px-4 py-4">
               <div class="flex items-center justify-between">
                   <a href="/" class="text-2xl font-bold text-orange-600">Mi Tech Store</a>

                   <form action="{{ route('search') }}" method="GET" class="flex-1 mx-8">
                       <div class="relative">
                           <input type="text"
                                  name="q"
                                  value="{{ request('q') }}"
                                  placeholder="Поиск товаров..."
                                  class="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-orange-500"
                                  maxlength="200">
                           <button type="submit"
                                   class="absolute right-2 top-2 text-gray-500 hover:text-orange-600">
                               <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                   <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                               </svg>
                           </button>
                       </div>
                   </form>
               </div>
           </div>
       </header>
       ```

    4. Create search results view (resources/views/storefront/products/search.blade.php):
       ```blade
       @extends('layouts.app')

       @section('content')
       <div class="container mx-auto px-4 py-8">
           <h1 class="text-2xl font-bold mb-4">
               Результаты поиска: "{{ $query }}"
               <span class="text-gray-500 text-lg">({{ $total }} товаров)</span>
           </h1>

           @if($products->isEmpty())
               <div class="text-center py-12">
                   <p class="text-gray-600 mb-4">По вашему запросу ничего не найдено</p>
                   <a href="/products" class="text-orange-600 hover:underline">Посмотреть все товары</a>
               </div>
           @else
               <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                   @foreach($products as $product)
                       <x-product-card :product="$product" />
                   @endforeach
               </div>

               <div class="mt-8">
                   {{ $products->links() }}
               </div>
           @endif
       </div>
       @endsection
       ```

    Why this approach:
    - Eloquent LIKE query uses prepared statements (prevents SQL injection)
    - Input validation limits query length
    - Empty state handled gracefully
    - Search term persists in pagination
    - Results count shown to user
  </action>
  <verify>
    ```bash
    # Verify route registered
    php artisan route:list | grep search

    # Test search controller
    php artisan tinker --execute="
    \$request = new Illuminate\Http\Request(['q' => 'Xiaomi']);
    \$controller = new App\Http\Controllers\Storefront\SearchController();
    \$response = \$controller->index(\$request);
    echo 'Search works';
    "

    # Test SQL injection prevention (should not break)
    curl "http://localhost:8000/search?q='; DROP TABLE products; --"
    ```
  </verify>
  <done>
    - SearchController implements safe LIKE queries
    - Search route registered at /search
    - Search form in header layout
    - Search results view with empty state
    - Input validation prevents malicious queries
    - SQL injection attempts fail safely
  </done>
</task>

<task type="auto">
  <name>Add price and specification filtering to product listings</name>
  <files>
    app/Http/Controllers/Storefront/ProductController.php
    resources/views/components/product-filter.blade.php
    resources/views/storefront/products/index.blade.php
    resources/views/storefront/categories/show.blade.php
  </files>
  <action>
    1. Update ProductController index() to handle filters:
       ```php
       public function index(Request $request)
       {
           // Validate filter inputs
           $validated = $request->validate([
               'price_min' => 'nullable|integer|min:0',
               'price_max' => 'nullable|integer|min:0',
               'memory' => 'nullable|string|max:50',
               'color' => 'nullable|string|max:50',
           ]);

           $query = Product::where('is_active', true)
               ->with('categories');

           // Price range filter (prices stored in cents)
           if ($request->filled('price_min')) {
               $query->where('price', '>=', $request->price_min * 100); // Convert KGS to cents
           }
           if ($request->filled('price_max')) {
               $query->where('price', '<=', $request->price_max * 100);
           }

           // Specification filters via attributes table
           if ($request->filled('memory')) {
               $query->whereHas('attributes', function ($q) use ($request) {
                   $q->where('key', 'Память')
                     ->where('value', 'LIKE', '%' . $request->memory . '%');
               });
           }

           if ($request->filled('color')) {
               $query->whereHas('attributes', function ($q) use ($request) {
                   $q->where('key', 'Цвет')
                     ->where('value', $request->color);
               });
           }

           $products = $query->paginate(20)->appends($request->except('page'));

           // Get unique values for filter dropdowns
           $memoryOptions = \App\Models\ProductAttribute::where('key', 'Память')
               ->distinct()
               ->pluck('value');

           $colorOptions = \App\Models\ProductAttribute::where('key', 'Цвет')
               ->distinct()
               ->pluck('value');

           return view('storefront.products.index', compact(
               'products',
               'memoryOptions',
               'colorOptions'
           ));
       }
       ```

       CRITICAL: Input validation prevents malicious filter values
       CRITICAL: whereHas() with prepared statements prevents SQL injection
       CRITICAL: appends() maintains filter state in pagination links

    2. Update CategoryController similarly:
       ```php
       public function show(Category $category, Request $request)
       {
           // Same validation and filtering logic as ProductController
           $validated = $request->validate([
               'price_min' => 'nullable|integer|min:0',
               'price_max' => 'nullable|integer|min:0',
               'memory' => 'nullable|string|max:50',
           ]);

           $query = $category->products()
               ->where('is_active', true)
               ->with('categories');

           // Apply same filters as ProductController
           if ($request->filled('price_min')) {
               $query->where('price', '>=', $request->price_min * 100);
           }
           if ($request->filled('price_max')) {
               $query->where('price', '<=', $request->price_max * 100);
           }

           $products = $query->paginate(20)->appends($request->except('page'));

           return view('storefront.categories.show', compact('category', 'products'));
       }
       ```

    3. Create filter component (resources/views/components/product-filter.blade.php):
       ```blade
       @props(['memoryOptions' => [], 'colorOptions' => []])

       <aside class="bg-white p-6 rounded-lg shadow">
           <h3 class="font-bold text-lg mb-4">Фильтры</h3>

           <form method="GET" action="{{ url()->current() }}">
               <!-- Price Range Filter -->
               <div class="mb-6">
                   <h4 class="font-semibold mb-2">Цена (сом)</h4>
                   <div class="grid grid-cols-2 gap-2">
                       <input type="number"
                              name="price_min"
                              value="{{ request('price_min') }}"
                              placeholder="От"
                              class="px-3 py-2 border rounded"
                              min="0">
                       <input type="number"
                              name="price_max"
                              value="{{ request('price_max') }}"
                              placeholder="До"
                              class="px-3 py-2 border rounded"
                              min="0">
                   </div>
               </div>

               <!-- Memory Filter -->
               @if($memoryOptions->isNotEmpty())
               <div class="mb-6">
                   <h4 class="font-semibold mb-2">Память</h4>
                   <select name="memory" class="w-full px-3 py-2 border rounded">
                       <option value="">Все</option>
                       @foreach($memoryOptions as $option)
                           <option value="{{ $option }}"
                                   {{ request('memory') == $option ? 'selected' : '' }}>
                               {{ $option }}
                           </option>
                       @endforeach
                   </select>
               </div>
               @endif

               <!-- Color Filter -->
               @if($colorOptions->isNotEmpty())
               <div class="mb-6">
                   <h4 class="font-semibold mb-2">Цвет</h4>
                   <select name="color" class="w-full px-3 py-2 border rounded">
                       <option value="">Все</option>
                       @foreach($colorOptions as $option)
                           <option value="{{ $option }}"
                                   {{ request('color') == $option ? 'selected' : '' }}>
                               {{ $option }}
                           </option>
                       @endforeach
                   </select>
               </div>
               @endif

               <!-- Filter Buttons -->
               <div class="flex gap-2">
                   <button type="submit"
                           class="flex-1 bg-orange-600 text-white py-2 rounded hover:bg-orange-700">
                       Применить
                   </button>
                   <a href="{{ url()->current() }}"
                      class="flex-1 bg-gray-200 text-gray-700 py-2 rounded text-center hover:bg-gray-300">
                       Сбросить
                   </a>
               </div>
           </form>

           <!-- Active Filters Display -->
           @if(request()->anyFilled(['price_min', 'price_max', 'memory', 'color']))
           <div class="mt-4 pt-4 border-t">
               <h4 class="font-semibold text-sm mb-2">Активные фильтры:</h4>
               <div class="flex flex-wrap gap-2">
                   @if(request('price_min'))
                       <span class="text-xs bg-gray-100 px-2 py-1 rounded">
                           От {{ number_format(request('price_min')) }} сом
                       </span>
                   @endif
                   @if(request('price_max'))
                       <span class="text-xs bg-gray-100 px-2 py-1 rounded">
                           До {{ number_format(request('price_max')) }} сом
                       </span>
                   @endif
                   @if(request('memory'))
                       <span class="text-xs bg-gray-100 px-2 py-1 rounded">
                           {{ request('memory') }}
                       </span>
                   @endif
                   @if(request('color'))
                       <span class="text-xs bg-gray-100 px-2 py-1 rounded">
                           {{ request('color') }}
                       </span>
                   @endif
               </div>
           </div>
           @endif
       </aside>
       ```

    4. Update products/index.blade.php to include filter sidebar:
       ```blade
       @extends('layouts.app')

       @section('content')
       <div class="container mx-auto px-4 py-8">
           <h1 class="text-3xl font-bold mb-6">Все товары</h1>

           <div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
               <!-- Filter Sidebar -->
               <div class="lg:col-span-1">
                   <x-product-filter :memoryOptions="$memoryOptions ?? []"
                                     :colorOptions="$colorOptions ?? []" />
               </div>

               <!-- Product Grid -->
               <div class="lg:col-span-3">
                   @if($products->isEmpty())
                       <p class="text-gray-600">Нет товаров, соответствующих фильтрам</p>
                   @else
                       <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                           @foreach($products as $product)
                               <x-product-card :product="$product" />
                           @endforeach
                       </div>

                       <div class="mt-8">
                           {{ $products->links() }}
                       </div>
                   @endif
               </div>
           </div>
       </div>
       @endsection
       ```

    5. Update ProductSeeder to add color/memory attributes:
       ```php
       // After creating products, add attributes
       use App\Models\ProductAttribute;

       $product = Product::where('name', 'Xiaomi 14 Pro')->first();
       ProductAttribute::create(['product_id' => $product->id, 'key' => 'Цвет', 'value' => 'Черный']);
       ProductAttribute::create(['product_id' => $product->id, 'key' => 'Память', 'value' => '256GB']);

       $product = Product::where('name', 'Redmi Note 13 Pro')->first();
       ProductAttribute::create(['product_id' => $product->id, 'key' => 'Цвет', 'value' => 'Синий']);
       ProductAttribute::create(['product_id' => $product->id, 'key' => 'Память', 'value' => '128GB']);
       ```

    Why this approach:
    - Input validation prevents filter injection attacks
    - Price filter works with integer cents storage
    - Attribute filters use prepared statements (safe from SQL injection)
    - Filter state persists in URL (shareable links)
    - Active filters displayed to user
    - Reset button clears all filters
  </action>
  <verify>
    ```bash
    # Re-seed with attributes
    php artisan db:seed --class=ProductSeeder

    # Test filter controller logic
    php artisan tinker --execute="
    \$request = new Illuminate\Http\Request(['price_min' => 10000, 'price_max' => 50000]);
    \$controller = new App\Http\Controllers\Storefront\ProductController();
    \$response = \$controller->index(\$request);
    echo 'Filter works';
    "

    # Test filter UI
    curl "http://localhost:8000/products?price_min=10000&price_max=50000"

    # Verify filter state persists
    curl "http://localhost:8000/products?memory=256GB&page=2" | grep -i "256GB"
    ```
  </verify>
  <done>
    - ProductController handles price and specification filters
    - CategoryController has same filtering capability
    - Filter component renders price range, memory, color dropdowns
    - Filter state persists in pagination links
    - Active filters displayed to user
    - Reset button clears filters
    - ProductSeeder adds sample attributes for testing
    - Input validation prevents malicious filter values
  </done>
</task>

</tasks>

<verification>
Full search and filter verification:

```bash
# 1. Test search functionality
curl "http://localhost:8000/search?q=Xiaomi" | grep -i "результаты поиска"

# 2. Test price filter
curl "http://localhost:8000/products?price_min=10000&price_max=50000"

# 3. Test specification filter
curl "http://localhost:8000/products?memory=256GB"

# 4. Test combined filters
curl "http://localhost:8000/products?price_min=20000&memory=128GB"

# 5. Test SQL injection prevention
curl "http://localhost:8000/search?q=' OR 1=1 --" | grep -v "error"

# 6. Test filter persistence in pagination
curl "http://localhost:8000/products?memory=256GB&page=2" | grep "memory=256GB"

# 7. Manual testing
# - Visit http://localhost:8000/products
# - Use filter sidebar to filter by price
# - Select memory option from dropdown
# - Verify filtered results
# - Click pagination - filters should persist
# - Click reset - filters should clear
```

Expected results:
- Search returns matching products
- Price filter narrows results correctly
- Specification filters work
- Multiple filters combine properly
- SQL injection attempts fail safely
- Filter state persists across pagination
- Reset button clears all filters
</verification>

<success_criteria>
Search and filtering complete when:

1. **Search Functionality**:
   - Search form in header layout
   - SearchController handles queries safely
   - Search results page with product grid
   - Empty state for no results
   - Search term persists in pagination

2. **Price Filtering**:
   - Price range inputs (min/max)
   - Filters work with integer cent storage
   - Price filter applies correctly
   - Filter state in URL parameters

3. **Specification Filtering**:
   - Memory filter dropdown with options
   - Color filter dropdown (if applicable)
   - Filters query product_attributes table
   - Multiple filters combine correctly

4. **Filter UI/UX**:
   - Filter sidebar on product listing pages
   - Active filters displayed
   - Reset button clears all filters
   - Filter state persists in pagination
   - Empty state for no matching products

5. **Security**:
   - Input validation on all filter fields
   - Prepared statements prevent SQL injection
   - Search query length limited
   - No security warnings in tests

6. **Manual Testing**:
   - Search for "Xiaomi" returns products
   - Filter by price range works
   - Filter by memory works
   - Combine search + filters works
   - Pagination maintains filter state
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-product-catalog/01-03-SUMMARY.md` documenting:
- Search implementation details
- Filter types added (price, memory, color)
- Security measures applied
- Filter UI components created
- Any challenges with specification filtering
- Key file paths for Phase 2 reference
</output>
