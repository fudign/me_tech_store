---
phase: 04-polish-launch
plan: 03
type: execute
wave: 2
depends_on: [04-01, 04-02]
files_modified:
  - database/migrations/2026_01_XX_add_performance_indexes.php
  - app/Http/Controllers/ProductController.php
  - app/Http/Controllers/Admin/ProductController.php
  - app/Models/Setting.php
  - app/Exceptions/Handler.php
  - resources/views/errors/database-unavailable.blade.php
  - .env.production
  - config/cache.php
  - config/session.php
  - routes/web.php
autonomous: true

must_haves:
  truths:
    - "Database queries use indexes for slug, price, category_id, is_active lookups"
    - "Product catalog queries execute in <100ms with 1000+ products"
    - "Category navigation menu is cached and doesn't query database on every page load"
    - "Site settings (phone, address) are cached and load instantly"
    - "Production environment runs with optimized configuration (cache, debug off, HTTPS)"
    - "Site shows user-friendly error page when database is unavailable instead of stack trace"
  artifacts:
    - path: "database/migrations/2026_01_XX_add_performance_indexes.php"
      provides: "Database indexes on filtered/sorted columns"
      contains: "index"
    - path: ".env.production"
      provides: "Production-ready environment configuration template"
      min_lines: 30
    - path: "app/Models/Setting.php"
      contains: "Cache::remember"
    - path: "app/Exceptions/Handler.php"
      provides: "Database error detection and graceful degradation"
      contains: "PDOException"
    - path: "resources/views/errors/database-unavailable.blade.php"
      provides: "User-friendly database error page"
      min_lines: 20
  key_links:
    - from: "app/Http/Controllers/ProductController.php"
      to: "Cache facade"
      via: "Cache::tags() wrapping product queries"
      pattern: "Cache::tags.*products"
    - from: "app/Models/Setting.php"
      to: "Cache facade"
      via: "get() method with Cache::remember"
      pattern: "Cache::remember.*settings"
    - from: "app/Exceptions/Handler.php"
      to: "resources/views/errors/database-unavailable.blade.php"
      via: "Custom error view for database exceptions"
      pattern: "database-unavailable"
---

<objective>
Optimize database queries, implement intelligent caching, handle database errors gracefully, and prepare production deployment configuration for fast, reliable performance under load.

Purpose: Without indexes, filtering 1000 products by price requires full table scan (2+ seconds). Without caching, every page load queries settings, categories, product counts. Production with APP_DEBUG=true exposes sensitive data. Database unavailability crashes site with stack trace (ERR-02). This plan makes site production-ready with sub-100ms response times and graceful error handling.

Output: Indexed database, cached queries with tag-based invalidation, database error handling with user-friendly fallback page, production .env template, deployment checklist, and Laravel optimization commands ready to run.
</objective>

<execution_context>
@C:\Users\user\Desktop\mi_tech\.planning\workflows\execute-plan.md
@C:\Users\user\Desktop\mi_tech\.planning\templates\summary.md
</execution_context>

<context>
@C:\Users\user\Desktop\mi_tech\.planning\PROJECT.md
@C:\Users\user\Desktop\mi_tech\.planning\ROADMAP.md
@C:\Users\user\Desktop\mi_tech\.planning\STATE.md
@C:\Users\user\Desktop\mi_tech\.planning\phases\04-polish-launch\04-CONTEXT.md
@C:\Users\user\Desktop\mi_tech\.planning\phases\04-polish-launch\04-RESEARCH.md

## Prior Phase Context

Setting model uses static get()/set() helpers (03-02).
Product filtering by price and attributes implemented (01-03).
Pagination at 20 items per page (01-02).
Eager loading prevents N+1 queries in controllers (01-02, 02-03, 03-01).
Products and categories have is_active column (01-01).
File cache driver default in Laravel (config/cache.php).
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add database indexes for performance</name>
  <files>
    database/migrations/2026_01_XX_add_performance_indexes.php
  </files>
  <action>
Create migration: php artisan make:migration add_performance_indexes

In up() method, add indexes for frequently queried columns:

Products table:
- $table->index('slug') - Already exists from 01-01 (verify, don't duplicate)
- $table->index('is_active') - Filter active products in catalog
- $table->index('price') - Filter by price range (01-03 requirement)
- $table->index(['is_active', 'created_at']) - Composite index for active products sorted by date (common query)
- $table->index('created_at') - Sorting by newest

Categories table:
- $table->index('slug') - Already exists from 01-01 (verify, don't duplicate)
- $table->index('is_active') - Filter active categories in navigation

Product_attributes table:
- $table->index(['product_id', 'key']) - Join and filter by attribute key (e.g., "Память")
- $table->index('key') - Filter products by specific attribute

Orders table:
- $table->index('status') - Admin order filtering by status (02-03)
- $table->index('created_at') - Order list sorting

In down() method: Drop all created indexes using $table->dropIndex(['column_name']) or $table->dropIndex('index_name').

Run migration: php artisan migrate

Why composite index (is_active, created_at): Most common query is "show active products sorted by date". Composite index optimized for this exact use case. Single-column indexes would be less efficient.

Why index on product_attributes.key: Filtering by memory (Память: 256GB) requires fast lookup on key column. Without index, every filter scans entire attributes table.

Verify indexes created:
```sql
SHOW INDEX FROM products;
SHOW INDEX FROM categories;
SHOW INDEX FROM product_attributes;
```
  </action>
  <verify>
```bash
cat database/migrations/*add_performance_indexes.php | grep -E "(\->index|Index)"
php artisan migrate:status
```
Migration file contains multiple index() calls.
Migration listed as complete in migrate:status.
  </verify>
  <done>
Database indexes created on frequently queried and filtered columns.
Composite index on (is_active, created_at) optimizes catalog queries.
Attribute filtering accelerated with indexes on product_id and key.
Query performance verified with EXPLAIN (filesort eliminated).
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement cache for product catalog and settings</name>
  <files>
    app/Http/Controllers/ProductController.php
    app/Models/Setting.php
    app/Http/Controllers/Admin/ProductController.php
  </files>
  <action>
Update ProductController::index() method:
- Wrap product query with cache:
```php
$page = $request->get('page', 1);
$filters = $request->only(['category', 'price_min', 'price_max', 'search', 'memory', 'color']);
$cacheKey = 'products_' . md5(json_encode(array_merge($filters, ['page' => $page])));

$products = Cache::tags('catalog')->remember($cacheKey, now()->addHours(6), function () use ($request) {
    // Existing query logic with filters and pagination
    return Product::with(['categories', 'attributes'])
        ->where('is_active', true)
        // ... apply filters ...
        ->paginate(20)
        ->appends($request->query());
});
```
- Keep existing filter logic unchanged
- Import: use Illuminate\Support\Facades\Cache;

Update Setting model (app/Models/Setting.php):
- Modify static get() method to use cache:
```php
public static function get($key, $default = null)
{
    return Cache::remember("setting_{$key}", now()->addDay(), function () use ($key, $default) {
        return self::where('key', $key)->value('value') ?? $default;
    });
}
```
- Modify static set() method to invalidate cache after save:
```php
public static function set($key, $value)
{
    self::updateOrCreate(['key' => $key], ['value' => $value]);
    Cache::forget("setting_{$key}");
}
```

Update Admin/ProductController:
- In store() method after product created: Cache::tags('catalog')->flush();
- In update() method after product saved: Cache::tags(['catalog', "product_{$product->id}"])->flush();
- In destroy() method after product deleted: Cache::tags('catalog')->flush();

Update Admin/CategoryController (if not already done):
- In store/update/destroy: Cache::tags('catalog')->flush(); (categories affect product display)

Why 6 hour TTL for products: Balances freshness with performance. Admin updates flush cache immediately. TTL safety net prevents stale cache if flush fails.

Why 24 hour TTL for settings: Settings rarely change (phone number, address). 1-day cache significantly reduces database load.

Why cache tags: Allow invalidating related caches without knowing exact keys. Updating product flushes all catalog pages. Alternative: manual key management is error-prone.

Note on cache tags: Cache tags require Redis or Memcached driver. File cache doesn't support tags. Implementation uses conditional check: if cache driver supports tags (config('cache.default') !== 'file'), use Cache::tags(); otherwise use simple Cache::remember() without tags and Cache::flush() invalidates all cache (acceptable for file driver in dev/staging).

Why NO route-level cache middleware: Model-level caching (Cache::remember in controllers) is sufficient and more flexible. Route-level response caching (spatie/laravel-responsecache) would cache entire HTML response including CSRF tokens and user-specific data, causing issues. Current approach caches only expensive database queries while allowing dynamic page content.
  </action>
  <verify>
```bash
grep -n "Cache::tags.*catalog\|Cache::remember" app/Http/Controllers/ProductController.php app/Http/Controllers/Admin/ProductController.php
grep -n "Cache::remember.*setting" app/Models/Setting.php
grep -n "Cache::forget\|Cache::flush" app/Models/Setting.php app/Http/Controllers/Admin/ProductController.php
```
ProductController wraps catalog query with cache.
Setting model caches get() and invalidates on set().
Admin controllers flush cache on product/category changes.
  </verify>
  <done>
Product catalog cached with tag-based invalidation (6-hour TTL).
Site settings cached for 24 hours, invalidated on admin update.
Admin product/category updates automatically flush relevant caches.
Cache implementation falls back gracefully if tags unsupported (file driver).
Model-level caching provides flexibility without route-level response caching complexity.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement database error handling (ERR-02)</name>
  <files>
    app/Exceptions/Handler.php
    resources/views/errors/database-unavailable.blade.php
  </files>
  <action>
**Update Exception Handler (app/Exceptions/Handler.php):**

Add custom error handling for database connection failures:
- In register() method, add renderable callback:
```php
$this->renderable(function (\PDOException $e, $request) {
    // Database connection errors (SQLSTATE[HY000] [2002])
    if (strpos($e->getMessage(), 'SQLSTATE') !== false) {
        \Log::error('Database connection failed', [
            'error' => $e->getMessage(),
            'url' => $request->fullUrl(),
            'ip' => $request->ip(),
        ]);

        if ($request->expectsJson()) {
            return response()->json([
                'error' => 'Сервис временно недоступен. Попробуйте позже.',
                'code' => 'DATABASE_UNAVAILABLE'
            ], 503);
        }

        return response()->view('errors.database-unavailable', [], 503);
    }
});

$this->renderable(function (\Illuminate\Database\QueryException $e, $request) {
    // Catch query exceptions caused by connection loss during operation
    if (str_contains($e->getMessage(), 'server has gone away') ||
        str_contains($e->getMessage(), 'Connection refused')) {
        \Log::error('Database query failed - connection lost', [
            'error' => $e->getMessage(),
            'url' => $request->fullUrl(),
        ]);

        if ($request->expectsJson()) {
            return response()->json([
                'error' => 'Сервис временно недоступен. Попробуйте позже.',
                'code' => 'DATABASE_ERROR'
            ], 503);
        }

        return response()->view('errors.database-unavailable', [], 503);
    }
});
```

**Create Custom Error View (resources/views/errors/database-unavailable.blade.php):**

Create user-friendly error page styled to match site design:
```blade
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Сервис временно недоступен - Xiaomi Store</title>
    @vite(['resources/css/app.css'])
</head>
<body class="bg-gray-100">
    <div class="min-h-screen flex items-center justify-center px-4">
        <div class="max-w-md w-full bg-white rounded-lg shadow-lg p-8 text-center">
            <div class="mb-6">
                <svg class="mx-auto h-16 w-16 text-orange-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                </svg>
            </div>
            <h1 class="text-2xl font-bold text-gray-900 mb-4">Сервис временно недоступен</h1>
            <p class="text-gray-600 mb-6">
                Извините, в данный момент мы проводим технические работы.
                Пожалуйста, попробуйте обновить страницу через несколько минут.
            </p>
            <div class="space-y-3">
                <button onclick="location.reload()" class="w-full bg-orange-600 text-white px-6 py-3 rounded-lg hover:bg-orange-700 transition">
                    Обновить страницу
                </button>
                <a href="/" class="block w-full bg-gray-100 text-gray-700 px-6 py-3 rounded-lg hover:bg-gray-200 transition">
                    Вернуться на главную
                </a>
            </div>
            <p class="text-sm text-gray-500 mt-6">
                Если проблема сохраняется, свяжитесь с нами:
                <a href="tel:+996XXXXXXXXX" class="text-orange-600 hover:underline">+996 XXX XXX XXX</a>
            </p>
        </div>
    </div>
</body>
</html>
```

**Why this approach (ERR-02 requirement):**
- Catches PDOException (database connection refused, network errors)
- Catches QueryException (connection lost during query execution)
- Logs error details for debugging (error message, URL, IP)
- Shows user-friendly Russian message instead of stack trace
- Provides retry mechanism (refresh button)
- Different responses for web (HTML page) vs API (JSON error)
- 503 status code indicates temporary unavailability (correct for database downtime)

**Graceful degradation:** Page loads even if database is down. No sensitive information exposed to users. Admins can check logs (storage/logs/laravel.log) for diagnostic details.

**Production benefit:** If database container restarts or network hiccup occurs, users see friendly error instead of "SQLSTATE[HY000] [2002] Connection refused" stack trace with file paths and query details.
  </action>
  <verify>
```bash
grep -n "PDOException\|QueryException" app/Exceptions/Handler.php
cat resources/views/errors/database-unavailable.blade.php | grep -E "(Сервис временно недоступен|503)"
```
Exception Handler contains database error detection logic.
Custom error view exists with user-friendly Russian messaging.
  </verify>
  <done>
Database connection errors caught and logged (ERR-02 requirement).
User-friendly error page displayed instead of stack trace when database unavailable.
API requests receive JSON error response with 503 status.
Error page styled to match site design with retry and navigation options.
Production-safe: no sensitive information exposed to end users.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create production environment template and deployment checklist</name>
  <files>
    .env.production
    DEPLOYMENT.md
  </files>
  <action>
Create .env.production template file at project root:
```env
# Application
APP_NAME="Xiaomi Store"
APP_ENV=production
APP_KEY=base64:CHANGE_THIS_AFTER_php_artisan_key:generate
APP_DEBUG=false
APP_URL=https://yourdomain.com

# Database
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=xiaomi_store_production
DB_USERNAME=xiaomi_user
DB_PASSWORD=CHANGE_TO_STRONG_PASSWORD

# Cache & Session (use Redis if available, file otherwise)
CACHE_DRIVER=redis
SESSION_DRIVER=redis
QUEUE_CONNECTION=sync

# Redis (if using Redis for cache/session)
REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379

# Mail (configure if email notifications needed)
MAIL_MAILER=smtp
MAIL_HOST=smtp.gmail.com
MAIL_PORT=587
MAIL_USERNAME=your-email@gmail.com
MAIL_PASSWORD=your-app-password
MAIL_ENCRYPTION=tls
MAIL_FROM_ADDRESS=noreply@yourdomain.com
MAIL_FROM_NAME="${APP_NAME}"

# Security
SESSION_LIFETIME=120
SESSION_SECURE_COOKIE=true
SESSION_SAME_SITE=lax

# Logging
LOG_CHANNEL=daily
LOG_LEVEL=error
```

Create DEPLOYMENT.md at project root:
```markdown
# Xiaomi Store - Production Deployment Checklist

## Pre-Deployment

- [ ] Backup existing database (if updating existing site)
- [ ] Test all features in staging environment
- [ ] Run `composer install --no-dev --optimize-autoloader`
- [ ] Run `npm ci && npm run build` (Vite production build)

## Server Setup

- [ ] PHP 8.2+ installed with extensions: mbstring, xml, curl, gd, mysql
- [ ] MySQL 8.0+ or MariaDB 10.3+
- [ ] Composer installed globally
- [ ] Redis installed (optional but recommended for cache/session)
- [ ] Web server configured (nginx or Apache with mod_rewrite)

## Environment Configuration

- [ ] Copy `.env.production` to `.env`
- [ ] Update `APP_URL` with production domain (https://yourdomain.com)
- [ ] Run `php artisan key:generate` (generates APP_KEY)
- [ ] Update database credentials (DB_HOST, DB_DATABASE, DB_USERNAME, DB_PASSWORD)
- [ ] Set `CACHE_DRIVER=redis` if Redis available, otherwise `file`
- [ ] Set `SESSION_DRIVER=redis` if Redis available, otherwise `file`
- [ ] Verify `APP_DEBUG=false` and `APP_ENV=production`

## Database Setup

- [ ] Create production database: `CREATE DATABASE xiaomi_store_production CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;`
- [ ] Run migrations: `php artisan migrate --force`
- [ ] Seed database: `php artisan db:seed` (creates admin user and sample products)
- [ ] Verify admin login: email admin@example.com, password admin123 (CHANGE IMMEDIATELY)

## File Permissions

- [ ] `chmod -R 755 storage bootstrap/cache`
- [ ] `chown -R www-data:www-data storage bootstrap/cache` (Linux/nginx)
- [ ] Verify `php artisan storage:link` creates public/storage symlink

## Laravel Optimization

- [ ] `php artisan config:cache` (cache configuration)
- [ ] `php artisan route:cache` (cache routes)
- [ ] `php artisan view:cache` (precompile Blade templates)
- [ ] `php artisan event:cache` (cache events)
- [ ] Combined: `php artisan optimize` (runs all above)

## Initial Data

- [ ] Generate sitemap: `php artisan sitemap:generate`
- [ ] Verify sitemap accessible: https://yourdomain.com/sitemap.xml
- [ ] Verify robots.txt: https://yourdomain.com/robots.txt
- [ ] Test image optimization: Visit product page, check WebP loading in Network tab

## SSL/HTTPS

- [ ] Install Let's Encrypt certificate: `certbot --nginx -d yourdomain.com`
- [ ] Enable auto-renewal: `certbot renew --dry-run`
- [ ] Verify redirect HTTP -> HTTPS working
- [ ] Test SSL: https://www.ssllabs.com/ssltest/

## Scheduler (Cron)

- [ ] Add to crontab: `* * * * * cd /path/to/project && php artisan schedule:run >> /dev/null 2>&1`
- [ ] Verify scheduler working: `php artisan schedule:list` (should show sitemap:generate daily)

## Verification

- [ ] Homepage loads without errors
- [ ] Browse products and categories
- [ ] Add product to cart, complete checkout
- [ ] Login to admin panel (yourdomain.com/admin)
- [ ] Create test product with images in admin
- [ ] Verify images load as WebP in browser (inspect Network tab)
- [ ] Share product link, check OpenGraph preview
- [ ] Check PageSpeed Insights score (aim for 70+ mobile, 90+ desktop)

## Error Handling Test (ERR-02)

- [ ] Stop MySQL service temporarily: `sudo systemctl stop mysql`
- [ ] Visit site: Should show "Сервис временно недоступен" page (not stack trace)
- [ ] Check logs: `tail storage/logs/laravel.log` (should contain PDOException with URL/IP)
- [ ] Restart MySQL: `sudo systemctl start mysql`
- [ ] Site should work normally again

## Post-Deployment

- [ ] Change default admin password immediately
- [ ] Monitor error logs: `tail -f storage/logs/laravel.log`
- [ ] Set up monitoring (optional): Laravel Pulse, Sentry, or similar
- [ ] Submit sitemap to Google Search Console and Yandex Webmaster

## Troubleshooting

**500 Error:** Check `storage/logs/laravel.log`, verify file permissions
**Images not loading:** Run `php artisan storage:link`, check storage/ permissions
**Cache not working:** Verify CACHE_DRIVER setting, test with `php artisan cache:clear`
**Sitemap empty:** Run `php artisan sitemap:generate`, check products have is_active=1
**Database error page not showing:** Verify APP_DEBUG=false, check Handler.php renderable callbacks

---
Last updated: 2026-01-23
```

Do NOT commit .env.production to git (it's template only, contains placeholder secrets). Add to .gitignore if not already there.
  </action>
  <verify>
```bash
cat .env.production | grep -E "(APP_ENV=production|APP_DEBUG=false|SESSION_SECURE_COOKIE=true)"
cat DEPLOYMENT.md | grep -E "(Checklist|php artisan optimize|certbot|ERR-02)"
grep ".env.production" .gitignore || echo ".env.production should be in .gitignore"
```
.env.production exists with production-safe defaults.
DEPLOYMENT.md contains comprehensive checklist with verification steps and ERR-02 testing.
Environment template not committed to git.
  </verify>
  <done>
.env.production template created with production-optimized settings.
DEPLOYMENT.md checklist covers server setup, Laravel optimization, SSL, and verification.
Checklist includes ERR-02 testing procedure (stop MySQL, verify friendly error page).
Template includes Redis configuration, security settings, and deployment commands.
Admin knows exact steps to deploy site safely to production and verify error handling.
  </done>
</task>

</tasks>

<verification>
1. Run EXPLAIN on product catalog query: Uses indexes, no filesort, <100ms execution
2. Test cache hit: Visit catalog twice, second visit shows cache hit in Telescope/Debugbar
3. Update product in admin: Catalog cache flushed, next visit regenerates cache
4. Check Setting::get() performance: <5ms (cached), no database query
5. Review .env.production: All critical settings correct (debug off, HTTPS on, strong security)
6. Follow DEPLOYMENT.md checklist in staging environment: All steps executable, site launches successfully
7. Test database error handling: Stop MySQL, visit site, see friendly error page (not stack trace)
8. Check logs: Database error logged with URL and IP, no sensitive data exposed to user
</verification>

<success_criteria>
- Database indexes reduce query time from 500ms+ to <100ms with 1000+ products
- Product catalog serves from cache (6-hour TTL), flushed automatically on admin updates
- Site settings cached for 24 hours, database queries eliminated for common lookups
- Database connection errors show user-friendly error page instead of stack trace (ERR-02)
- Error details logged for debugging without exposing sensitive information to users
- .env.production template ready with all production-critical settings configured
- DEPLOYMENT.md provides executable checklist from server setup to verification
- Laravel optimization commands (config:cache, route:cache, view:cache) ready to run
- Production deployment requires zero guesswork - follow checklist, site goes live
</success_criteria>

<output>
After completion, create `.planning/phases/04-polish-launch/04-03-SUMMARY.md`
</output>
